{"meta":{"title":"Hackjy's void heart","subtitle":"life in OI from zero","description":null,"author":"Hackjy","url":"http://yoursite.com"},"pages":[{"title":"文章分类","date":"2018-10-29T06:08:23.000Z","updated":"2018-11-07T08:06:16.558Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-10-27T11:17:02.000Z","updated":"2018-10-30T08:58:13.817Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"【题解】 P1332 血色先锋队","slug":"【题解】-P1332-血色先锋队","date":"2018-11-07T06:32:59.000Z","updated":"2018-11-07T08:07:20.958Z","comments":true,"path":"2018/11/07/【题解】-P1332-血色先锋队/","link":"","permalink":"http://yoursite.com/2018/11/07/【题解】-P1332-血色先锋队/","excerpt":"","text":"今天%你赛又被吊打了很不爽所以写一篇唯一会的题的题解来开心一下TAT 题目的大意就是让我们从不同的起点开始向外拓展，然后最先拓展的点就用一个ans的二维数组存下来，因为luogu上面数据比较水，所以不建议大家用直接暴力算的方法（因为luogu数据比较水，所以暴力亲测还可以过，但最好是用搜索的方法我们可以把初始感染源都放在队列里面，然后不断的向外拓展，直到head=tail的时候退出，二维数组ans记录答案，每次记录的就是当前的ans=之前的队列拓展点+1就好了，因为广搜是单调的所以不用考虑大小问题上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ans[1001][1001],queue[1000001][2],head,tail,n,k1,k2,m;bool vis[1001][1001];int xx[4]=&#123;0,0,1,-1&#125;,yy[4]=&#123;1,-1,0,0&#125;;int main()&#123; memset(ans,127/3,sizeof(ans)); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;k1,&amp;k2); for(int i=1; i&lt;=k1; i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); queue[++tail][0]=x; queue[tail][1]=y; ans[x][y]=0; vis[x][y]=1; &#125; while(head&lt;tail) &#123; head++; for(int i=0; i&lt;4; i++) &#123; int sx=queue[head][0]+xx[i],sy=queue[head][1]+yy[i]; if(sx&gt;0 &amp;&amp; sy&gt;0 &amp;&amp; sx&lt;=n &amp;&amp; sy&lt;=m &amp;&amp; !vis[sx][sy]) &#123; vis[sx][sy]=1; queue[++tail][0]=sx; queue[tail][1]=sy; ans[sx][sy]=ans[queue[head][0]][queue[head][1]]+1; &#125; &#125; &#125; for(int i=1; i&lt;=k2; i++) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",ans[x][y]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"【学习笔记】 luogu-P1119-灾后重建","slug":"【学习笔记】 luogu-P1119-灾后重建","date":"2018-11-01T02:42:22.000Z","updated":"2018-11-07T06:28:01.037Z","comments":true,"path":"2018/11/01/【学习笔记】 luogu-P1119-灾后重建/","link":"","permalink":"http://yoursite.com/2018/11/01/【学习笔记】 luogu-P1119-灾后重建/","excerpt":"","text":"今天小蒟蒻做了一道和最短路有关的题qwq （虽然是看的题解，但是受益匪浅啊qwq，作一篇笔记放在这里以后可以用来复习题目大意的就是让我们从第零天开始，每一天都会更新一些村庄，这些村庄里面有路，但是呢因为有的没修好，所以只有两边都修好的路才能通，题目就是让我们对Q次询问每次都做出一个答案来这个题一看就会想到Floyd啊（毕竟范围辣么小,但是呢我们需要在这上面修改一些东西，用一个数组t[k]来保存第k个村庄修好的时间，因为说了是顺序的，所以给我们减少了很多的麻烦，我们只需要在这基础上让k不断地递增就可以来判断是不是有dis值能使a到b当然t数组的保存有两种办法，小蒟蒻选择的是题解的方法（才不会告诉你们我是看了半天才看的qwq，第一种是开始就给上面附上最大值，这样我们就可以不用在while循环里面判断是不是k&lt;n啦qwq，还有一种就是直接for赋值但要在k递增的时候判断是不是越界了（没辣么多村庄你修辣么多干什么qwq上代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define re registerusing namespace std;int dis[1001][1001],t[1000001],n,m,Q,k;int main()&#123; memset(dis,0x3f,sizeof(dis)); memset(t,0x3f,sizeof(t)); scanf(\"%d%d\",&amp;n,&amp;m); for(re int i=0; i&lt;=n-1; i++) scanf(\"%d\",&amp;t[i]),dis[i][i]=0; for(re int i=1; i&lt;=m; i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); dis[a][b]=dis[b][a]=c; &#125; scanf(\"%d\",&amp;Q); for(re int i=1; i&lt;=Q; i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); while(t[k]&lt;=c) &#123; for(re int i=0; i&lt;=n-1; i++) for(re int j=0; j&lt;=n-1; j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); k++; &#125; if(dis[a][b]==0x3f3f3f3f || t[a]&gt;c || t[b]&gt;c) printf(\"-1\\n\"); else printf(\"%d\\n\",dis[a][b]); &#125;&#125;","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"【题解】 luogu P1025 数的划分","slug":"index","date":"2018-10-31T11:09:29.756Z","updated":"2018-10-31T11:10:41.384Z","comments":true,"path":"2018/10/31/index/","link":"","permalink":"http://yoursite.com/2018/10/31/index/","excerpt":"","text":"小蒟蒻好久没有写一篇搜索的题解了（明明可以DP的说，今天用DFS解决一下这道题目观察题意，我们可以发现题目中所求的组合总数的序列是一个单调不下降的序列，那么我们在DFS时设置参数就可以设置三个，分别是K1（保存还能用的数的个数），sum（当前记录的使用的数的和），num（当前序列选的数）在这里多讲一下num这个参数，因为选的数的序列是单调不下降的，所以我们选的数一定比前面大或者相同，因此我们可以用num保存当前选的数，这样就可以保证序列不会重，并且这也是个简单的优化。（虽然不如DP快，但是好想啊qwq，并且亲测DP空间比DFS要大一点（虽然时间快了N倍QAQ））上代码（代码中也有部分解释1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ans=0,n,k;void dfs(int num,int sum,int k1)&#123; if(k1==0) &#123; if(sum==n) &#123; ans++; return; &#125; else return; &#125; for(int i=num; sum+i&lt;=n; i++)//sum+i&lt;=n是一个很简单的优化，防止溢出并减少循环次数（其实还有更好地优化就是其他大佬题解里的%%%） dfs(i,sum+i,k1-1);//（dfs深度优先一层层向下搜索就行了）&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); if(k==1)&#123; printf(\"1\"); return 0; &#125;//有一点小懒qwq，其实不用，因为n很小 dfs(1,0,k); printf(\"%d\",ans);//输出方案总数&#125;","categories":[],"tags":[]},{"title":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads","slug":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads","date":"2018-10-31T10:27:30.000Z","updated":"2018-11-02T05:24:54.263Z","comments":true,"path":"2018/10/31/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/","link":"","permalink":"http://yoursite.com/2018/10/31/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/","excerpt":"","text":"为什么这么多恶意评分啊qwq，这题明明很水的说好那么我们首先来看一下题意，题目让我们先找一边把需要建的一等公路先建出来（等级高就是可以为所欲为，然后再把剩余需要建的二等公路建出来其实我们可以用一个结构体，里面开两个dis值，分别代表一等和二等，手打两个cmp，排序之后疯狂找就好了qwq但是注意，由于题目让我们输出的是方案和最大值，而不是价钱，所以我们在跑kruskal的时候要注意把每一步的过程用一个数组保存下来，这样最后再筛一遍就能直接输出啦qwq剩下的一些过程放在代码里了qwq #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct Edge1{ int x,y,dis1,dis2,num;//dis1表示一等，dis2表示二等 }a1[100001]; int father[100001],k,m,n,maxx=0,k1=0,f[100001][2],m1=0; //f[1]表示建一等公路的序号f[0]表示二等的序号，结构体的num即可以表示 bool cmp1(Edge1 x,Edge1 y){return x.dis1&lt;y.dis1;}//一等排序 bool cmp2(Edge1 x,Edge1 y){return x.dis2&lt;y.dis2;}//二等排序 int find(int x)//找爹 { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } void unionn(int x,int y)//咱俩合起来了qwq！！ { x=find(x),y=find(y); father[x]=y; } int main() { scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m); m--;//先减一好计算（其实是我容易忘 for(int i=1; i&lt;=n; i++) father[i]=i;//初始化 for(int i=1; i&lt;=m; i++) { int x,y,c1,c2; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;c1,&amp;c2); a1[i].x=x; a1[i].y=y; a1[i].dis1=c1;a1[i].dis2=c2; a1[i].num=i;//一定把序号存上 } sort(a1+1,a1+m+1,cmp1);//一等先来 for(int i=1; i&lt;=m; i++)//标准最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][1]=1; //保存此时你选择的边序号 } if(k1==k) { maxx=a1[i].dis1; break; } } k1=0; sort(a1+1,a1+m+1,cmp2); for(int i=1; i&lt;=m; i++)//二等再跑一遍最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][0]=1; } if(k1==n-k-1) { maxx=max(maxx,a1[i].dis2); break; } } printf(\"%d\\n\",maxx); for(int i=1; i&lt;=m; i++) if(f[i][1]!=0) printf(\"%d 1\\n\",i); else if(f[i][0]!=0) printf(\"%d 2\\n\",i); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"【颓废向】(长期置顶)(不定期更新)机房dalao们的日常","slug":"page【颓废向】（机房dalao们的日常）","date":"2018-10-30T08:27:20.000Z","updated":"2018-11-07T08:05:50.845Z","comments":true,"path":"2018/10/30/page【颓废向】（机房dalao们的日常）/","link":"","permalink":"http://yoursite.com/2018/10/30/page【颓废向】（机房dalao们的日常）/","excerpt":"","text":"众所周知，slyz是一个神奇的学校 ，这个神奇的学校里面有着各种各样的大佬们（除了本蒟蒻），那么就让hackjy同学给大家看看这个神奇的学校里面神奇的dalao的sd红太阳！一面吧qwq 那么首先是……Juan_feng！(教父！)没错，你没有看错，就是我们的Juan_feng神！OrzOrz为什么说他神呢，，，因为他的OI事迹可以用四个字来形容：毒！瘤！数！据！结！构！下面的一篇文章来自于@Steve_braveman 一位喜欢各种各样的数据结构的dalao写的题解应该是这样的（校门外的数据结构？？？-&gt;然后就成了一篇这样的题解 用了三种数据结构完成了一道模拟题。。。机房里的其他人是这么评价的就连我们巨强的已经能领取小本本的学长也来评论了Juan_feng的题解 让我们来看看大佬平时的言论（大雾我%我自己 怒斥周边同机房dalao(其实本人并不暴躁（逃 flag! ？？ %%% 神就是可以为所欲为! 神仙总语录（雾身为机房毒瘤数据结构的代表，Juan_feng优良的传递了他一贯的毒瘤作风，用各种各样的数据结构来做一道十分正常的题目：“一定可以卡过去的！” “YNOI…不就是简单的分块吗?(认真脸)”（已经做了好几道YNOI的Juan_feng) “你只要分块入门YNOI都可以做了啊qwq（认真）” 我：“Juan_feng能教我怎么做DP么QAQ” Juan_feng:“DP是什么，我不会DP（假）”（逃 然后。。。我发现了他的小号 我：“Juan_feng这道题。。。” Juan_feng:“我不会qwq！”过了两秒 Juan_feng:“暴力！模拟！” 然后。。。 Juan_feng:“诶等等这不是线段树emm。。。不对不对珂朵莉树的话。。。” 最后。。 Juan_feng：“分块！这题一看肯定分块啊！” 我：“。。。” 记住这句话：：在这个世界上比jc还恐怖的：我jc我自己 好了那么下一位大佬是学校清北爷钦定正解的dalao与数论金牌爷同一所学校的Red_dye!(红色染料!)这位dalao是一个不折不扣的。。。emmm二次元小将（大雾为什么这么说呢？因为。。。（你要我怎么给你看100+的galgame和各种各样的qwq啊啊（他曾经自以为打出暴力结果打的正解还觉得自己的程序就是暴力%%%“我觉得伊莉雅是最可爱的！” 过了一会。。“啊啊啊啊啊我的小北方”（喜欢穿着FFF团的衣服再抱着个滑稽四处晃悠最常说的一句话：（qwq？ovo？TAT？qvq？owo？QAQ？quq？喵喵喵数论金牌爷嫡传弟子（逃“我要吃面！”（指着学校的辣椒并加了三大勺）“这什么破辣椒啊，一点也不辣。”“我发现我不能跟着老师的思路走。。” “？” “他讲的太慢了我容易犯困啊啊啊啊” %%%（窗口抖动） lyx：“你玩过awlifdakew（某galgame）” 我：“哦哦哦（其实并不知道）” lyx：“哇那个机器人awlfdaslfj。。。” 我：“哦哦哦（雾）” lyx：“我得想办法把北方搞到府上来bulabula。。” 我：“他到底。。要说什么。。”非洲人与欧洲人的对话：“我单抽出奇迹！” “我单抽是sd。。”“诶我打了个rand出了10分？？” “。。¿”一个1T网盘+硬盘的人。。惹不起惹不起（逃（大多数时间都是他在讲我在听。。%%% 后来这个图片就变成了（某辣鸡P图师素质五连 吊打！！¿然后 ？？？智熄 好那让我们来看机房的第三位dalao - SuperGoodGame！（帅哥哥死光光） 这位大佬，怎么说呢，用他自己的话说，是一个吟游诗人（大雾，原先喜欢在机房和我乱对诗句（强行押韵我：“递推不是递归” SGG：“递归不是地推” 我：“所以不要把递推想成递归” SGG：“也不要把递归想成递推” SGG：“不如递堆！”沉默了几秒钟。。众人发出了爽朗的笑声；然后，SGG：“面包和大蒜是绝配（强行押韵）” “啊哈哈哈哈哈什么鬼”是和Juan_feng还有star_dust(后面会说）发小的人（都是dalaoqwq曾经在美国打三国杀选主公玩关羽张飞起手第一轮六张杀把忠臣star_dust砍翻的人（虽然最后赢了？？拥有迷之笑点，常常说出一些惊为天人（拼音表上找不到）的话“你个der”“啊啊好ler啊”……（人赢？）我：“SGG你写作业了？” SGG：“没啊” star_dust:“我好像写了。。” SGG:“啊你这个叛徒！你退群吧。。”过了一会，SGG：“等下我好像也写了qwq” 众人：“啊啊啊叛徒！。。”吾王的粉丝（“诶19年fate亚瑟王是男的？不看了不看了”）晚上在宿舍：我：“打牌么各位” Juan_feng(正无聊)：“好啊来啊！” SGG:“不打，睡觉，这辈子不可能打的” star_dust：“我随便”最后在我的软磨硬泡下，star_dust起床打牌了。。SGG：“等等加我一个！” 我们：“¿你不是不打么？” SGG：“F * （某脏词），你们都打牌打的我也想打了F” 我们：“真香！” SGG：“香香香真香”那天晚上他是最嗨的（诶star_dust别睡啊，来啊是唯一的打牌不记牌想打啥就打啥很随意的dalao（把Juan_feng逼急了“你别出这个啊！” SGG：“我咋知道你要啊。。” “你不看牌吗”“不看啊我按照自己的节奏” （一张大王把Juan_feng（队友）大王闷手上了，然后我赢了233是机房第一个也是被jc次数最多的人（大概得20次。。jc到最后：“啊我又AK了。。行吧” “你又把我AK了？。。好吧。。”今天更新正好是SGG大佬的生日啊，，所以先祝一波生日快乐的说qwq生日礼物： SGG：同样也是个%法师：SGG大佬%人的时候只是手掌举过头顶，挥舞着自己的手掌∽动物园中的猴子要食物，缺少了wzx五体投地的灵魂，和bj的土刨式%人有几分相似（逃（dalao会打我的QAQ）（马学创始人）（说啥都喜欢带一个“马”字）“为SGG大佬的诞生献上礼炮！！”（雾 未完待续（逃","categories":[],"tags":[{"name":"颓废向（日常","slug":"颓废向（日常","permalink":"http://yoursite.com/tags/颓废向（日常/"}]},{"title":"Hackjyの新家！","slug":"新家","date":"2018-10-27T11:09:45.000Z","updated":"2018-11-07T08:04:52.701Z","comments":true,"path":"2018/10/27/新家/","link":"","permalink":"http://yoursite.com/2018/10/27/新家/","excerpt":"","text":"今天hackjy搬家啦qwq，经过不懈的努力（其实还是靠了各路大佬和学长的帮忙）建好了自己的独立博客，原来的luogu博客也会时不时的更新，不过以后就主要在这里写文章啦，欢迎大家来拜访蒟蒻的博客啊qwq 原来博客的地址：hackjy的luogu博客!","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-27T07:39:34.528Z","updated":"2018-10-27T07:39:34.528Z","comments":true,"path":"2018/10/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}