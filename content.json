{"meta":{"title":"Hackjy's void heart","subtitle":"life in OI from zero","description":null,"author":"Hackjy","url":"http://yoursite.com"},"pages":[{"title":"文章分类","date":"2018-10-27T11:17:02.000Z","updated":"2018-10-30T08:58:13.817Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-10-29T06:08:23.000Z","updated":"2018-10-30T08:58:17.516Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-10-31T11:05:10.358Z","updated":"2018-10-31T11:05:10.358Z","comments":true,"path":"【题解】-luogu-P1025-数的划分/index.html","permalink":"http://yoursite.com/【题解】-luogu-P1025-数的划分/index.html","excerpt":"","text":""},{"title":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads","date":"2018-10-31T10:27:30.000Z","updated":"2018-10-31T10:27:40.524Z","comments":true,"path":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads.html","permalink":"http://yoursite.com/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads.html","excerpt":"","text":"为什么这么多恶意评分啊qwq，这题明明很水的说好那么我们首先来看一下题意，题目让我们先找一边把需要建的一等公路先建出来（等级高就是可以为所欲为，然后再把剩余需要建的二等公路建出来其实我们可以用一个结构体，里面开两个dis值，分别代表一等和二等，手打两个cmp，排序之后疯狂找就好了qwq但是注意，由于题目让我们输出的是方案和最大值，而不是价钱，所以我们在跑kruskal的时候要注意把每一步的过程用一个数组保存下来，这样最后再筛一遍就能直接输出啦qwq剩下的一些过程放在代码里了qwq另外，样例是错的qwq因为序号四建的应该是二等公路@lin_toto@chen_zhe #include #include #include #include #include using namespace std; struct Edge1{ int x,y,dis1,dis2,num;//dis1表示一等，dis2表示二等}a1[100001]; int father[100001],k,m,n,maxx=0,k1=0,f[100001][2],m1=0; //f[1]表示建一等公路的序号f[0]表示二等的序号，结构体的num即可以表示 bool cmp1(Edge1 x,Edge1 y){return x.dis1&lt;y.dis1;}//一等排序 bool cmp2(Edge1 x,Edge1 y){return x.dis2&lt;y.dis2;}//二等排序 int find(int x)//找爹{ if(father[x]!=x) father[x]=find(father[x]); return father[x];} void unionn(int x,int y)//咱俩合起来了qwq！！{ x=find(x),y=find(y); father[x]=y;} int main(){ scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m); m–;//先减一好计算（其实是我容易忘 for(int i=1; i&lt;=n; i++) father[i]=i;//初始化 for(int i=1; i&lt;=m; i++) { int x,y,c1,c2; scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;c1,&amp;c2); a1[i].x=x; a1[i].y=y; a1[i].dis1=c1;a1[i].dis2=c2; a1[i].num=i;//一定把序号存上 } sort(a1+1,a1+m+1,cmp1);//一等先来 for(int i=1; i&lt;=m; i++)//标准最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][1]=1; //保存此时你选择的边序号 } if(k1==k)//行啦你建的差不多了该建点便宜的了 { maxx=a1[i].dis1; break; } } k1=0; sort(a1+1,a1+m+1,cmp2); for(int i=1; i&lt;=m; i++)//二等再跑一遍最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][0]=1; } if(k1==n-k-1) { maxx=max(maxx,a1[i].dis2); break; } } printf(“%d\\n”,maxx); for(int i=1; i&lt;=m; i++) //找序号啦 if(f[i][1]!=0) printf(“%d 1\\n”,i); else if(f[i][0]!=0) printf(“%d 2\\n”,i);}"}],"posts":[{"title":"【学习笔记】 luogu-P1119-灾后重建","slug":"【学习笔记】 luogu-P1119-灾后重建","date":"2018-11-01T02:42:22.000Z","updated":"2018-11-01T02:55:05.259Z","comments":true,"path":"2018/11/01/【学习笔记】 luogu-P1119-灾后重建/","link":"","permalink":"http://yoursite.com/2018/11/01/【学习笔记】 luogu-P1119-灾后重建/","excerpt":"","text":"今天小蒟蒻做了一道和最短路有关的题qwq （虽然是看的题解，但是受益匪浅啊qwq，作一篇笔记放在这里以后可以用来复习先把题目放一下**题目背景 BBB地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。题目描述 给出BBB地区的村庄数NNN，村庄编号从000到N−1N-1N−1，和所有MMM条公路的长度，公路是双向的。并给出第iii个村庄重建完成的时间tit_iti​，你可以认为是同时开始重建并在第tit_iti​天重建完成，并且在当天即可通车。若tit_iti​为000则说明地震未对此地区造成损坏，一开始就可以通车。之后有QQQ个询问(x,y,t)(x, y, t)(x,y,t)，对于每个询问你要回答在第ttt天，从村庄xxx到村庄y的最短路径长度为多少。如果无法找到从xxx村庄到yyy村庄的路径，经过若干个已重建完成的村庄，或者村庄xxx或村庄yyy在第t天仍未重建完成 ，则需要返回−1-1−1。输入输出格式输入格式： 第一行包含两个正整数N,MN,MN,M，表示了村庄的数目与公路的数量。 第二行包含NNN个非负整数t0,t1,…,tN−1t_0, t_1,…, t_{N-1}t0​,t1​,…,tN−1​，表示了每个村庄重建完成的时间，数据保证了t0≤t1≤…≤tN−1t_0 ≤ t_1 ≤ … ≤ t_{N-1}t0​≤t1​≤…≤tN−1​。 接下来MMM行，每行333个非负整数i,j,wi, j, wi,j,w，www为不超过100001000010000的正整数，表示了有一条连接村庄iii与村庄jjj的道路，长度为www，保证i≠ji≠ji≠j，且对于任意一对村庄只会存在一条道路。 接下来一行也就是M+3M+3M+3行包含一个正整数QQQ，表示QQQ个询问。 接下来QQQ行，每行333个非负整数x,y,tx, y, tx,y,t，询问在第ttt天，从村庄xxx到村庄yyy的最短路径长度为多少，数据保证了ttt是不下降的。 输出格式： 共QQQ行，对每一个询问(x,y,t)(x, y, t)(x,y,t)输出对应的答案，即在第ttt天，从村庄xxx到村庄yyy的最短路径长度为多少。如果在第t天无法找到从xxx村庄到yyy村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄yyy在第ttt天仍未修复完成，则输出−1-1−1。 输入输出样例输入样例#1： 复制 4 51 2 3 40 2 12 3 13 1 22 1 40 3 542 0 20 1 20 1 30 1 4 输出样例#1： 复制 -1-154 说明 对于30%30\\%30%的数据，有N≤50N≤50N≤50； 对于30%30\\%30%的数据，有ti=0t_i= 0ti​=0，其中有20%20\\%20%的数据有ti=0t_i = 0ti​=0且N&gt;50N&gt;50N&gt;50； 对于50%50\\%50%的数据，有Q≤100Q≤100Q≤100； 对于100%100\\%100%的数据，有N≤200N≤200N≤200，M≤N×(N−1)/2M≤N \\times (N-1)/2M≤N×(N−1)/2，Q≤50000Q≤50000Q≤50000，所有输入数据涉及整数均不超过100000100000100000。** 这个题一看就会想到Floyd啊（毕竟范围辣么小,但是呢我们需要在这上面修改一些东西，用一个数组t[k]来保存第k个村庄修好的时间，因为说了是顺序的，所以给我们减少了很多的麻烦，我们只需要在这基础上让k不断地递增就可以来判断是不是有dis值能使a到b当然t数组的保存有两种办法，小蒟蒻选择的是题解的方法（才不会告诉你们我是看了半天才看的qwq，第一种是开始就给上面附上最大值，这样我们就可以不用在while循环里面判断是不是k&lt;n啦qwq，还有一种就是直接for赋值但要在k递增的时候判断是不是越界了（没辣么多村庄你修辣么多干什么qwq上代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define re registerusing namespace std;int dis[1001][1001],t[1000001],n,m,Q,k;int main()&#123; memset(dis,0x3f,sizeof(dis)); memset(t,0x3f,sizeof(t)); scanf(\"%d%d\",&amp;n,&amp;m); for(re int i=0; i&lt;=n-1; i++) scanf(\"%d\",&amp;t[i]),dis[i][i]=0; for(re int i=1; i&lt;=m; i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); dis[a][b]=dis[b][a]=c; &#125; scanf(\"%d\",&amp;Q); for(re int i=1; i&lt;=Q; i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); while(t[k]&lt;=c) &#123; for(re int i=0; i&lt;=n-1; i++) for(re int j=0; j&lt;=n-1; j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); k++; &#125; if(dis[a][b]==0x3f3f3f3f || t[a]&gt;c || t[b]&gt;c) printf(\"-1\\n\"); else printf(\"%d\\n\",dis[a][b]); &#125;&#125;","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"【题解】 luogu P1025 数的划分","slug":"index","date":"2018-10-31T11:09:29.756Z","updated":"2018-10-31T11:10:41.384Z","comments":true,"path":"2018/10/31/index/","link":"","permalink":"http://yoursite.com/2018/10/31/index/","excerpt":"","text":"小蒟蒻好久没有写一篇搜索的题解了（明明可以DP的说，今天用DFS解决一下这道题目观察题意，我们可以发现题目中所求的组合总数的序列是一个单调不下降的序列，那么我们在DFS时设置参数就可以设置三个，分别是K1（保存还能用的数的个数），sum（当前记录的使用的数的和），num（当前序列选的数）在这里多讲一下num这个参数，因为选的数的序列是单调不下降的，所以我们选的数一定比前面大或者相同，因此我们可以用num保存当前选的数，这样就可以保证序列不会重，并且这也是个简单的优化。（虽然不如DP快，但是好想啊qwq，并且亲测DP空间比DFS要大一点（虽然时间快了N倍QAQ））上代码（代码中也有部分解释1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ans=0,n,k;void dfs(int num,int sum,int k1)&#123; if(k1==0) &#123; if(sum==n) &#123; ans++; return; &#125; else return; &#125; for(int i=num; sum+i&lt;=n; i++)//sum+i&lt;=n是一个很简单的优化，防止溢出并减少循环次数（其实还有更好地优化就是其他大佬题解里的%%%） dfs(i,sum+i,k1-1);//（dfs深度优先一层层向下搜索就行了）&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); if(k==1)&#123; printf(\"1\"); return 0; &#125;//有一点小懒qwq，其实不用，因为n很小 dfs(1,0,k); printf(\"%d\",ans);//输出方案总数&#125;","categories":[],"tags":[]},{"title":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads","slug":"【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads","date":"2018-10-31T10:27:30.000Z","updated":"2018-11-02T05:24:54.263Z","comments":true,"path":"2018/10/31/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/","link":"","permalink":"http://yoursite.com/2018/10/31/【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads/","excerpt":"","text":"为什么这么多恶意评分啊qwq，这题明明很水的说好那么我们首先来看一下题意，题目让我们先找一边把需要建的一等公路先建出来（等级高就是可以为所欲为，然后再把剩余需要建的二等公路建出来其实我们可以用一个结构体，里面开两个dis值，分别代表一等和二等，手打两个cmp，排序之后疯狂找就好了qwq但是注意，由于题目让我们输出的是方案和最大值，而不是价钱，所以我们在跑kruskal的时候要注意把每一步的过程用一个数组保存下来，这样最后再筛一遍就能直接输出啦qwq剩下的一些过程放在代码里了qwq #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct Edge1{ int x,y,dis1,dis2,num;//dis1表示一等，dis2表示二等 }a1[100001]; int father[100001],k,m,n,maxx=0,k1=0,f[100001][2],m1=0; //f[1]表示建一等公路的序号f[0]表示二等的序号，结构体的num即可以表示 bool cmp1(Edge1 x,Edge1 y){return x.dis1&lt;y.dis1;}//一等排序 bool cmp2(Edge1 x,Edge1 y){return x.dis2&lt;y.dis2;}//二等排序 int find(int x)//找爹 { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } void unionn(int x,int y)//咱俩合起来了qwq！！ { x=find(x),y=find(y); father[x]=y; } int main() { scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m); m--;//先减一好计算（其实是我容易忘 for(int i=1; i&lt;=n; i++) father[i]=i;//初始化 for(int i=1; i&lt;=m; i++) { int x,y,c1,c2; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;c1,&amp;c2); a1[i].x=x; a1[i].y=y; a1[i].dis1=c1;a1[i].dis2=c2; a1[i].num=i;//一定把序号存上 } sort(a1+1,a1+m+1,cmp1);//一等先来 for(int i=1; i&lt;=m; i++)//标准最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][1]=1; //保存此时你选择的边序号 } if(k1==k) { maxx=a1[i].dis1; break; } } k1=0; sort(a1+1,a1+m+1,cmp2); for(int i=1; i&lt;=m; i++)//二等再跑一遍最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][0]=1; } if(k1==n-k-1) { maxx=max(maxx,a1[i].dis2); break; } } printf(\"%d\\n\",maxx); for(int i=1; i&lt;=m; i++) if(f[i][1]!=0) printf(\"%d 1\\n\",i); else if(f[i][0]!=0) printf(\"%d 2\\n\",i); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"【颓废向】（机房dalao们的日常）","slug":"page【颓废向】（机房dalao们的日常）","date":"2018-10-30T08:27:20.000Z","updated":"2018-11-01T03:11:20.640Z","comments":true,"path":"2018/10/30/page【颓废向】（机房dalao们的日常）/","link":"","permalink":"http://yoursite.com/2018/10/30/page【颓废向】（机房dalao们的日常）/","excerpt":"","text":"众所周知，slyz是一个神奇的学校 ，这个神奇的学校里面有着各种各样的大佬们（除了本蒟蒻），那么就让hackjy同学给大家看看这个神奇的学校里面神奇的dalao的sd红太阳！一面吧qwq 那么首先是……Juan_feng！(教父！)没错，你没有看错，就是我们的Juan_feng神！OrzOrz为什么说他神呢，，，因为他的OI事迹可以用四个字来形容：毒！瘤！数！据！结！构！下面的一篇文章来自于@Steve_braveman 一位喜欢各种各样的数据结构的dalao写的题解应该是这样的（校门外的数据结构？？？-&gt;然后就成了一篇这样的题解 用了三种数据结构完成了一道模拟题。。。机房里的其他人是这么评价的就连我们巨强的已经能领取小本本的学长也来评论了Juan_feng的题解 让我们来看看大佬平时的言论（大雾我%我自己 怒斥周边同机房dalao(其实本人并不暴躁（逃 flag! ？？ %%% 神就是可以为所欲为! 神仙总语录（雾身为机房毒瘤数据结构的代表，Juan_feng优良的传递了他一贯的毒瘤作风，用各种各样的数据结构来做一道十分正常的题目：“一定可以卡过去的！” “YNOI…不就是简单的分块吗?(认真脸)”（已经做了好几道YNOI的Juan_feng) “你只要分块入门YNOI都可以做了啊qwq（认真）” 我：“Juan_feng能教我怎么做DP么QAQ” Juan_feng:“DP是什么，我不会DP（假）”（逃 然后。。。我发现了他的小号 我：“Juan_feng这道题。。。” Juan_feng:“我不会qwq！”过了两秒 Juan_feng:“暴力！模拟！” 然后。。。 Juan_feng:“诶等等这不是线段树emm。。。不对不对珂朵莉树的话。。。” 最后。。 Juan_feng：“分块！这题一看肯定分块啊！” 我：“。。。” 记住这句话：：在这个世界上比jc还恐怖的：我jc我自己 好了那么下一位大佬是学校清北爷钦定正解的dalao与数论金牌爷同一所学校的Red_dye!(红色染料!)这位dalao是一个不折不扣的。。。emmm二次元小将（大雾为什么这么说呢？因为。。。（你要我怎么给你看100+的galgame和各种各样的qwq啊啊（他曾经自以为打出暴力结果打的正解还觉得自己的程序就是暴力%%%“我觉得伊莉雅是最可爱的！” 过了一会。。“啊啊啊啊啊我的小北方”（喜欢穿着FFF团的衣服再抱着个滑稽四处晃悠最常说的一句话：（qwq？ovo？TAT？qvq？owo？QAQ？quq？喵喵喵数论金牌爷嫡传弟子（逃“我要吃面！”（指着学校的辣椒并加了三大勺）“这什么破辣椒啊，一点也不辣。”“我发现我不能跟着老师的思路走。。” “？” “他讲的太慢了我容易犯困啊啊啊啊” %%%（窗口抖动） lyx：“你玩过awlifdakew（某galgame）” 我：“哦哦哦（其实并不知道）” lyx：“哇那个机器人awlfdaslfj。。。” 我：“哦哦哦（雾）” lyx：“我得想办法把北方搞到府上来bulabula。。” 我：“他到底。。要说什么。。”非洲人与欧洲人的对话：“我单抽出奇迹！” “我单抽是sd。。”“诶我打了个rand出了10分？？” “。。¿”一个1T网盘+硬盘的人。。惹不起惹不起（逃（大多数时间都是他在讲我在听。。%%% 后来这个图片就变成了（某辣鸡P图师素质五连 吊打！！¿然后 ？？？智熄 好那让我们来看机房的第三位dalao - SuperGoodGame！（帅哥哥死光光） 这位大佬，怎么说呢，用他自己的话说，是一个吟游诗人（大雾，原先喜欢在机房和我乱对诗句（强行押韵我：“递推不是递归” SGG：“递归不是地推” 我：“所以不要把递推想成递归” SGG：“也不要把递归想成递推” SGG：“不如递堆！”沉默了几秒钟。。众人发出了爽朗的笑声；然后，SGG：“面包和大蒜是绝配（强行押韵）” “啊哈哈哈哈哈什么鬼”是和Juan_feng还有star_dust(后面会说）发小的人（都是dalaoqwq曾经在美国打三国杀选主公玩关羽张飞起手第一轮六张杀把忠臣star_dust砍翻的人（虽然最后赢了？？拥有迷之笑点，常常说出一些惊为天人（拼音表上找不到）的话“你个der”“啊啊好ler啊”……（人赢？）我：“SGG你写作业了？” SGG：“没啊” star_dust:“我好像写了。。” SGG:“啊你这个叛徒！你退群吧。。”过了一会，SGG：“等下我好像也写了qwq” 众人：“啊啊啊叛徒！。。”吾王的粉丝（“诶19年fate亚瑟王是男的？不看了不看了”）晚上在宿舍：我：“打牌么各位” Juan_feng(正无聊)：“好啊来啊！” SGG:“不打，睡觉，这辈子不可能打的” star_dust：“我随便”最后在我的软磨硬泡下，star_dust起床打牌了。。SGG：“等等加我一个！” 我们：“¿你不是不打么？” SGG：“F * （某脏词），你们都打牌打的我也想打了F” 我们：“真香！” SGG：“香香香真香”那天晚上他是最嗨的（诶star_dust别睡啊，来啊是唯一的打牌不记牌想打啥就打啥很随意的dalao（把Juan_feng逼急了“你别出这个啊！” SGG：“我咋知道你要啊。。” “你不看牌吗”“不看啊我按照自己的节奏” （一张大王把Juan_feng（队友）大王闷手上了，然后我赢了233是机房第一个也是被jc次数最多的人（大概得20次。。jc到最后：“啊我又AK了。。行吧” “你又把我AK了？。。好吧。。”今天更新正好是SGG大佬的生日啊，，所以先祝一波生日快乐的说qwq生日礼物： SGG：同样也是个%法师：SGG大佬%人的时候只是手掌举过头顶，挥舞着自己的手掌∽动物园中的猴子要食物，缺少了wzx五体投地的灵魂，和bj的土刨式%人有几分相似（逃（dalao会打我的QAQ）（马学创始人）（说啥都喜欢带一个“马”字）“为SGG大佬的诞生献上礼炮！！”（雾 未完待续（逃","categories":[],"tags":[{"name":"颓废向（日常","slug":"颓废向（日常","permalink":"http://yoursite.com/tags/颓废向（日常/"}]},{"title":"新家qwq！","slug":"1","date":"2018-10-27T11:09:45.000Z","updated":"2018-10-31T07:21:08.982Z","comments":true,"path":"2018/10/27/1/","link":"","permalink":"http://yoursite.com/2018/10/27/1/","excerpt":"","text":"今天hackjy搬家啦qwq，经过不懈的努力（其实还是靠了各路大佬和学长的帮忙）建好了自己的独立博客，原来的luogu博客也会时不时的更新，不过以后就主要在这里写文章啦，欢迎大家来拜访蒟蒻的博客啊qwq 原来博客的地址：hackjy的luogu博客!","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-27T07:39:34.528Z","updated":"2018-10-27T07:39:34.528Z","comments":true,"path":"2018/10/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}