<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】luogu P2210 Haywire]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-P2210-Haywire%2F</url>
    <content type="text"><![CDATA[明天就NOIP了我还在这里学玄学算法真的是要死啊QAQ 算了还是贴上一篇题解吧qwq，毕竟是人生中第一篇黑题题解qwq，首先不会模拟退火的或者不会原理的请出门右转模拟退火原理+使用看一下题目，可以发现这个题就是让我们在所有的组合中找出一个最优解来，符合我们模拟退火的使用条件，所以我们可以开始考虑如何确定每一个值了剩下的注意的地方和一些做法就放在代码里了qwq 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define re register#define max(a,b) (a&gt;b?a:b)#define min(a,b) (a&lt;b?a:b)using namespace std;int n;int a[15][4];int p[100],p1[101],linshi,x,y,dc;const double starttem=1e9;const double endtime=0.999;const double changet=0.99;const double endtem=1e-14;//mnth四位大大 int abss(int x)&#123; return x&gt;0?x:x*-1;&#125;int sum() //求和 &#123; int ans=0; for(re int i=1; i&lt;=n; i++) for(re int j=1; j&lt;=3; j++) ans+=abss(p1[i]-p1[a[i][j]]); return ans;&#125;inline void change(int x,int y) //交换两个值&#123; int t=p1[x]; p1[x]=p1[y]; p1[y]=t;&#125;int srandom(int a,int b) //非酋的最后一搏&#123; return rand()%(b-a+1)+a;&#125; int main()&#123; srand(time(NULL)); srand(rand()+23333333); srand(rand()+19260817);//东方之力祝我成功 srand(rand());//玄学四连 scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d%d%d",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3]); p[i]=i; //永远不变的初始位置 p1[i]=i;//变幻莫测的位置 &#125; dc=sum();//先求初始解 while((clock()/(1.0*CLOCKS_PER_SEC))&lt;=endtime) &#123; for(re int i=1; i&lt;=n; i++) p1[i]=p[i]; //先初始化好初值 for(re double t=starttem; t&gt;=endtem; t*=changet) &#123; linshi=dc; do &#123; x=srandom(1,n); y=srandom(1,n); &#125;while(x==y); //玩命找死 change(x,y); linshi=sum(); if(linshi&lt;=dc) dc=linshi; //看看是否比原先的更优 else if((exp(dc-linshi)*1.0/t&gt;(rand()*1.0/RAND_MAX))) change(x,y); //用一定的概率接受该解（毕竟有比你优的，但是你肯定要把不优的换回去啊qwq &#125; &#125; printf("%d",dc/2);//因为计算了两次，所以要除2，例如计算a-b你算a的时候计算了一次但你又在b时候又计算了所以必须除掉 &#125; 祝大家食用愉快qwq]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1757【通天之分组背包】]]></title>
    <url>%2F2018%2F11%2F07%2F%E9%A2%98%E8%A7%A3-P1757%E3%80%90%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E3%80%91%2F</url>
    <content type="text"><![CDATA[这是一道分组背包的裸板子题啊qwq，今天小蒟蒻来给大家讲一下分组背包的简单使用方法（毕竟难的也不会啊TAT（逃 首先看一下题目 题目背景直达通天路·小A历险记第二篇 题目描述自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。 输入输出格式输入格式：两个数m,n，表示一共有n件物品，总重量为m 接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数 输出格式：一个数，最大的利用价值 输入输出样例输入样例#1： 复制45 310 10 110 5 150 400 2输出样例#1： 复制10说明1&lt;=m&lt;=1000 1&lt;=n&lt;=1000 组数t&lt;=100 首先我们用一个数组w[i]来保存每个物品的重量，c[i]表示每个物品的价值，定义二维数组a[p][0]表示第p组的物品有a[p][0]件，里面存储这个物品的序号为[i]，定义一个变量t来保存一共有多少组物品。 那么这个题的状态转移方程就变得非常简单啦，大致类似于01背包，注意控制循环变量的时候把组数放在外面（或许只有本蒟蒻犯了这种zz的错误QAQ 下面状态转移方程和循环变量就在代码里啦qwq 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int w[10001],t,c[10001],v,f[10001],a[10001][1001],m,n,p;int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d%d%d",&amp;w[i],&amp;c[i],&amp;p); a[p][++a[p][0]]=i; t=max(t,p); &#125; for(int k=1; k&lt;=t; k++)//控制组数 for(int j=m; j&gt;=0; j--)//容量 for(int i=1; i&lt;=a[k][0]; i++)//枚举 if(w[a[k][i]]&lt;=j)//先判断能不能放 f[j]=max(f[j],f[j-w[a[k][i]]]+c[a[k][i]]); printf("%d",f[m]);&#125;]]></content>
      <categories>
        <category>动态规划/背包</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 P1064 金明的预算方案]]></title>
    <url>%2F2018%2F11%2F07%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-P1064-%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[~~（啊啊啊这个sd题目卡了我半天QAQ 我为什么可以这么傻啊）~~ 题目大意这里就不放了qwq，相信大家也能看懂quq 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为55等：用整数1-51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 这个题目我们可以考虑用分组背包做，因为每一组最多只有两个附件，那么我们分组背包里面的策略数也就有5种：选主件，主件+附件1，主件+附件2，主件+附件1+附件2，我们可以在预处理的时候把这几个状态都枚举出来 此外，因为状态很少，所以预处理的时候也可以判断每一个背包里面是不是都有两个附件，没有的话直接退出或者加它那一个附件就好了 附件所获得的价值用c[i]表示，需要花费w[i]的体力，这样我们可以在找附件的时候直接把它加上主件就好了，因为每个策略是互斥的，所以我们不用在意会不会选主件+附件会多加一遍主件 分组背包的原理就不讲了，请参考背包九讲qwq（逃 下面放上代码（代码里面也有部分注释qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int a[10001][6],f[100001],w[10001],c[10001],n,m,t;//不会链表QAQ，就只能用数组模拟存储 int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; int k; scanf("%d%d%d",&amp;w[i],&amp;c[i],&amp;k); c[i]*=w[i];//直接把价值乘上 if(k!=0)//如果不是主件就加到它依附的主件序号后面 a[k][++a[k][0]]=i; else //是主件就加一组以他的序号为头的背包（千万不要图省空间qwq &#123; t+=i; a[i][++a[i][0]]=i; &#125; &#125; for(int i=1; i&lt;=t; i++) &#123; if(a[i][0]&gt;2)//如果他有俩附件 &#123; a[i][0]++;m++; w[m]+=w[a[i][1]]+w[a[i][2]]+w[a[i][3]]; w[a[i][2]]+=w[a[i][1]]; w[a[i][3]]+=w[a[i][1]]; c[m]+=c[a[i][1]]+c[a[i][2]]+c[a[i][3]]; c[a[i][2]]+=c[a[i][1]]; c[a[i][3]]+=c[a[i][1]]; a[i][a[i][0]]=m; continue; &#125; if(a[i][0]&lt;2) continue; //咋一个附件都没有呢，跳过！qwq if(a[i][0]==2) //正好有一个附件 &#123; w[a[i][2]]+=w[a[i][1]]; c[a[i][2]]+=c[a[i][1]]; continue; &#125; &#125; for(int k=1; k&lt;=t; k++) //标准的分组背包 for(int j=n; j&gt;=0; j--) for(int i=1; i&lt;=a[k][0]; i++) if(j&gt;=w[a[k][i]])//一定注意判断一下是否能装 f[j]=max(f[j],f[j-w[a[k][i]]]+c[a[k][i]]); printf("%d",f[n]); &#125;]]></content>
      <categories>
        <category>动态规划/背包</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 P1332 血色先锋队]]></title>
    <url>%2F2018%2F11%2F07%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-P1332-%E8%A1%80%E8%89%B2%E5%85%88%E9%94%8B%E9%98%9F%2F</url>
    <content type="text"><![CDATA[今天%你赛又被吊打了很不爽所以写一篇唯一会的题的题解来开心一下TAT 题目的大意就是让我们从不同的起点开始向外拓展，然后最先拓展的点就用一个ans的二维数组存下来，因为luogu上面数据比较水，所以不建议大家用直接暴力算的方法（因为luogu数据比较水，所以暴力亲测还可以过，但最好是用搜索的方法我们可以把初始感染源都放在队列里面，然后不断的向外拓展，直到head=tail的时候退出，二维数组ans记录答案，每次记录的就是当前的ans=之前的队列拓展点+1就好了，因为广搜是单调的所以不用考虑大小问题上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ans[1001][1001],queue[1000001][2],head,tail,n,k1,k2,m;bool vis[1001][1001];int xx[4]=&#123;0,0,1,-1&#125;,yy[4]=&#123;1,-1,0,0&#125;;int main()&#123; memset(ans,127/3,sizeof(ans)); scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k1,&amp;k2); for(int i=1; i&lt;=k1; i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); queue[++tail][0]=x; queue[tail][1]=y; ans[x][y]=0; vis[x][y]=1; &#125; while(head&lt;tail) &#123; head++; for(int i=0; i&lt;4; i++) &#123; int sx=queue[head][0]+xx[i],sy=queue[head][1]+yy[i]; if(sx&gt;0 &amp;&amp; sy&gt;0 &amp;&amp; sx&lt;=n &amp;&amp; sy&lt;=m &amp;&amp; !vis[sx][sy]) &#123; vis[sx][sy]=1; queue[++tail][0]=sx; queue[tail][1]=sy; ans[sx][sy]=ans[queue[head][0]][queue[head][1]]+1; &#125; &#125; &#125; for(int i=1; i&lt;=k2; i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",ans[x][y]); &#125;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】 luogu-P1119-灾后重建]]></title>
    <url>%2F2018%2F11%2F01%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%20luogu-P1119-%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[今天小蒟蒻做了一道和最短路有关的题qwq （虽然是看的题解，但是受益匪浅啊qwq，作一篇笔记放在这里以后可以用来复习题目大意的就是让我们从第零天开始，每一天都会更新一些村庄，这些村庄里面有路，但是呢因为有的没修好，所以只有两边都修好的路才能通，题目就是让我们对Q次询问每次都做出一个答案来这个题一看就会想到Floyd啊（毕竟范围辣么小,但是呢我们需要在这上面修改一些东西，用一个数组t[k]来保存第k个村庄修好的时间，因为说了是顺序的，所以给我们减少了很多的麻烦，我们只需要在这基础上让k不断地递增就可以来判断是不是有dis值能使a到b当然t数组的保存有两种办法，小蒟蒻选择的是题解的方法（才不会告诉你们我是看了半天才看的qwq，第一种是开始就给上面附上最大值，这样我们就可以不用在while循环里面判断是不是k&lt;n啦qwq，还有一种就是直接for赋值但要在k递增的时候判断是不是越界了（没辣么多村庄你修辣么多干什么qwq上代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define re registerusing namespace std;int dis[1001][1001],t[1000001],n,m,Q,k;int main()&#123; memset(dis,0x3f,sizeof(dis)); memset(t,0x3f,sizeof(t)); scanf("%d%d",&amp;n,&amp;m); for(re int i=0; i&lt;=n-1; i++) scanf("%d",&amp;t[i]),dis[i][i]=0; for(re int i=1; i&lt;=m; i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); dis[a][b]=dis[b][a]=c; &#125; scanf("%d",&amp;Q); for(re int i=1; i&lt;=Q; i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); while(t[k]&lt;=c) &#123; for(re int i=0; i&lt;=n-1; i++) for(re int j=0; j&lt;=n-1; j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); k++; &#125; if(dis[a][b]==0x3f3f3f3f || t[a]&gt;c || t[b]&gt;c) printf("-1\n"); else printf("%d\n",dis[a][b]); &#125;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 luogu P1025 数的划分]]></title>
    <url>%2F2018%2F10%2F31%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P1025%20%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[小蒟蒻好久没有写一篇搜索的题解了（明明可以DP的说，今天用DFS解决一下这道题目观察题意，我们可以发现题目中所求的组合总数的序列是一个单调不下降的序列，那么我们在DFS时设置参数就可以设置三个，分别是K1（保存还能用的数的个数），sum（当前记录的使用的数的和），num（当前序列选的数）在这里多讲一下num这个参数，因为选的数的序列是单调不下降的，所以我们选的数一定比前面大或者相同，因此我们可以用num保存当前选的数，这样就可以保证序列不会重，并且这也是个简单的优化。（虽然不如DP快，但是好想啊qwq，并且亲测DP空间比DFS要大一点（虽然时间快了N倍QAQ））上代码（代码中也有部分解释1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ans=0,n,k;void dfs(int num,int sum,int k1)&#123; if(k1==0) &#123; if(sum==n) &#123; ans++; return; &#125; else return; &#125; for(int i=num; sum+i&lt;=n; i++)//sum+i&lt;=n是一个很简单的优化，防止溢出并减少循环次数（其实还有更好地优化就是其他大佬题解里的%%%） dfs(i,sum+i,k1-1);//（dfs深度优先一层层向下搜索就行了）&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); if(k==1)&#123; printf("1"); return 0; &#125;//有一点小懒qwq，其实不用，因为n很小 dfs(1,0,k); printf("%d",ans);//输出方案总数&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【题解】luogu-P2872-USACO07DEC-道路建设Building-Roads]]></title>
    <url>%2F2018%2F10%2F31%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91luogu-P2872-USACO07DEC-%E9%81%93%E8%B7%AF%E5%BB%BA%E8%AE%BEBuilding-Roads%2F</url>
    <content type="text"><![CDATA[为什么这么多恶意评分啊qwq，这题明明很水的说好那么我们首先来看一下题意，题目让我们先找一边把需要建的一等公路先建出来（等级高就是可以为所欲为，然后再把剩余需要建的二等公路建出来其实我们可以用一个结构体，里面开两个dis值，分别代表一等和二等，手打两个cmp，排序之后疯狂找就好了qwq但是注意，由于题目让我们输出的是方案和最大值，而不是价钱，所以我们在跑kruskal的时候要注意把每一步的过程用一个数组保存下来，这样最后再筛一遍就能直接输出啦qwq剩下的一些过程放在代码里了qwq #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; struct Edge1{ int x,y,dis1,dis2,num;//dis1表示一等，dis2表示二等 }a1[100001]; int father[100001],k,m,n,maxx=0,k1=0,f[100001][2],m1=0; //f[1]表示建一等公路的序号f[0]表示二等的序号，结构体的num即可以表示 bool cmp1(Edge1 x,Edge1 y){return x.dis1&lt;y.dis1;}//一等排序 bool cmp2(Edge1 x,Edge1 y){return x.dis2&lt;y.dis2;}//二等排序 int find(int x)//找爹 { if(father[x]!=x) father[x]=find(father[x]); return father[x]; } void unionn(int x,int y)//咱俩合起来了qwq！！ { x=find(x),y=find(y); father[x]=y; } int main() { scanf("%d%d%d",&amp;n,&amp;k,&amp;m); m--;//先减一好计算（其实是我容易忘 for(int i=1; i&lt;=n; i++) father[i]=i;//初始化 for(int i=1; i&lt;=m; i++) { int x,y,c1,c2; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;c1,&amp;c2); a1[i].x=x; a1[i].y=y; a1[i].dis1=c1;a1[i].dis2=c2; a1[i].num=i;//一定把序号存上 } sort(a1+1,a1+m+1,cmp1);//一等先来 for(int i=1; i&lt;=m; i++)//标准最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][1]=1; //保存此时你选择的边序号 } if(k1==k) { maxx=a1[i].dis1; break; } } k1=0; sort(a1+1,a1+m+1,cmp2); for(int i=1; i&lt;=m; i++)//二等再跑一遍最小生成树 { if(find(a1[i].x)!=find(a1[i].y)) { unionn(a1[i].x,a1[i].y); k1++; f[a1[i].num][0]=1; } if(k1==n-k-1) { maxx=max(maxx,a1[i].dis2); break; } } printf("%d\n",maxx); for(int i=1; i&lt;=m; i++) if(f[i][1]!=0) printf("%d 1\n",i); else if(f[i][0]!=0) printf("%d 2\n",i); }]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【颓废向】(长期置顶)(不定期更新)机房dalao们的日常]]></title>
    <url>%2F2018%2F10%2F30%2Fpage%E3%80%90%E9%A2%93%E5%BA%9F%E5%90%91%E3%80%91%EF%BC%88%E6%9C%BA%E6%88%BFdalao%E4%BB%AC%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[众所周知，slyz是一个神奇的学校 ，这个神奇的学校里面有着各种各样的大佬们（除了本蒟蒻），那么就让hackjy同学给大家看看这个神奇的学校里面神奇的dalao的sd红太阳！一面吧qwq 那么首先是……Juan_feng！(教父！)没错，你没有看错，就是我们的Juan_feng神！OrzOrz为什么说他神呢，，，因为他的OI事迹可以用四个字来形容：毒！瘤！数！据！结！构！下面的一篇文章来自于@Steve_braveman 一位喜欢各种各样的数据结构的dalao写的题解应该是这样的（校门外的数据结构？？？-&gt;然后就成了一篇这样的题解 用了三种数据结构完成了一道模拟题。。。机房里的其他人是这么评价的就连我们巨强的已经能领取小本本的学长也来评论了Juan_feng的题解 让我们来看看大佬平时的言论（大雾我%我自己 大佬的flag(瑟瑟发抖.ing 神仙总语录（雾身为机房毒瘤数据结构的代表，Juan_feng优良的传递了他一贯的毒瘤作风，用各种各样的数据结构来做一道十分正常的题目：“一定可以卡过去的！” “YNOI…不就是简单的分块吗?(认真脸)”（已经做了好几道YNOI的Juan_feng) “你只要分块入门YNOI都可以做了啊qwq（认真）” 我：“Juan_feng能教我怎么做DP么QAQ” Juan_feng:“DP是什么，我不会DP（假）”（逃 然后。。。我发现了他的小号 我：“Juan_feng这道题。。。” Juan_feng:“我不会qwq！”过了两秒 Juan_feng:“暴力！模拟！” 然后。。。 Juan_feng:“诶等等这不是线段树emm。。。不对不对珂朵莉树的话。。。” 最后。。 Juan_feng：“分块！这题一看肯定分块啊！” 我：“。。。” 记住这句话：：在这个世界上比jc还恐怖的：我jc我自己 好了那么下一位大佬是学校清北爷钦定正解的dalao与数论金牌爷同一所学校的Red_dye!(红色染料!)这位dalao是一个不折不扣的。。。emmm二次元小将（大雾为什么这么说呢？因为。。。（你要我怎么给你看100+的galgame和各种各样的qwq啊啊（他曾经自以为打出暴力结果打的正解还觉得自己的程序就是暴力%%%“我觉得伊莉雅是最可爱的！” 过了一会。。“啊啊啊啊啊我的小北方”（喜欢穿着FFF团的衣服再抱着个滑稽四处晃悠最常说的一句话：（qwq？ovo？TAT？qvq？owo？QAQ？quq？喵喵喵数论金牌爷嫡传弟子（逃“我要吃面！”（指着学校的辣椒并加了三大勺）“这什么破辣椒啊，一点也不辣。”“我发现我不能跟着老师的思路走。。” “？” “他讲的太慢了我容易犯困啊啊啊啊” %%%（窗口抖动） lyx：“你玩过awlifdakew（某galgame）” 我：“哦哦哦（其实并不知道）” lyx：“哇那个机器人awlfdaslfj。。。” 我：“哦哦哦（雾）” lyx：“我得想办法把北方搞到府上来bulabula。。” 我：“他到底。。要说什么。。”非洲人与欧洲人的对话：“我单抽出奇迹！” “我单抽是sd。。”“诶我打了个rand出了10分？？” “。。¿”一个1T网盘+硬盘的人。。惹不起惹不起（逃（大多数时间都是他在讲我在听。。%%% 后来这个图片就变成了（某辣鸡P图师素质五连 吊打！！¿然后 ？？？智熄 好那让我们来看机房的第三位dalao - SuperGoodGame！（帅哥哥死光光） 这位大佬，怎么说呢，用他自己的话说，是一个吟游诗人（大雾，原先喜欢在机房和我乱对诗句（强行押韵我：“递推不是递归” SGG：“递归不是地推” 我：“所以不要把递推想成递归” SGG：“也不要把递归想成递推” SGG：“不如递堆！”沉默了几秒钟。。众人发出了爽朗的笑声；然后，SGG：“面包和大蒜是绝配（强行押韵）” “啊哈哈哈哈哈什么鬼”是和Juan_feng还有star_dust(后面会说）发小的人（都是dalaoqwq曾经在美国打三国杀选主公玩关羽张飞起手第一轮六张杀把忠臣star_dust砍翻的人（虽然最后赢了？？拥有迷之笑点，常常说出一些惊为天人（拼音表上找不到）的话“你个der”“啊啊好ler啊”……（人赢？）我：“SGG你写作业了？” SGG：“没啊” star_dust:“我好像写了。。” SGG:“啊你这个叛徒！你退群吧。。”过了一会，SGG：“等下我好像也写了qwq” 众人：“啊啊啊叛徒！。。”吾王的粉丝（“诶19年fate亚瑟王是男的？不看了不看了”）晚上在宿舍：我：“打牌么各位” Juan_feng(正无聊)：“好啊来啊！” SGG:“不打，睡觉，这辈子不可能打的” star_dust：“我随便”最后在我的软磨硬泡下，star_dust起床打牌了。。SGG：“等等加我一个！” 我们：“¿你不是不打么？” SGG：“F * （某脏词），你们都打牌打的我也想打了F” 我们：“真香！” SGG：“香香香真香”那天晚上他是最嗨的（诶star_dust别睡啊，来啊是唯一的打牌不记牌想打啥就打啥很随意的dalao（把Juan_feng逼急了“你别出这个啊！” SGG：“我咋知道你要啊。。” “你不看牌吗”“不看啊我按照自己的节奏” （一张大王把Juan_feng（队友）大王闷手上了，然后我赢了233是机房第一个也是被jc次数最多的人（大概得20次。。jc到最后：“啊我又AK了。。行吧” “你又把我AK了？。。好吧。。”今天更新正好是SGG大佬的生日啊，，所以先祝一波生日快乐的说qwq生日礼物： SGG：同样也是个%法师：SGG大佬%人的时候只是手掌举过头顶，挥舞着自己的手掌∽动物园中的猴子要食物，缺少了wzx五体投地的灵魂，和bj的土刨式%人有几分相似（逃（dalao会打我的QAQ）（马学创始人）（说啥都喜欢带一个“马”字）“为SGG大佬的诞生献上礼炮！！”（雾 未完待续（逃]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>颓废向（日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hackjyの新家！]]></title>
    <url>%2F2018%2F10%2F27%2F%E6%96%B0%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[今天hackjy搬家啦qwq，经过不懈的努力（其实还是靠了各路大佬和学长的帮忙）建好了自己的独立博客，原来的luogu博客也会时不时的更新，不过以后就主要在这里写文章啦，欢迎大家来拜访蒟蒻的博客啊qwq 原来博客的地址：hackjy的luogu博客!]]></content>
  </entry>
</search>
